import discord
import os
import sys
import traceback
import logging
import aiosqlite
import asyncio

from datetime import datetime
from discord.ext import commands, tasks
from discord.ext.commands import Bot as BotBase

from utilities import default
from ..db import asyncdb

DB_PATH = "/Users/siamakasasi/Desktop/☃️☃️☃️/Python/Bots/NGC0000/data/db/database.db"
BUILD_PATH = "./data/db/build.sql"




global_connection = None
global_cursor = None



discord_logger = logging.getLogger('discord')
discord_logger.setLevel(logging.CRITICAL)
error_handler = logging.FileHandler(filename="././data/logs/errors.log", encoding='utf-8')
discord_logger.addHandler(error_handler)


log = logging.getLogger()
log.setLevel(logging.DEBUG)
handler = logging.FileHandler(filename="././data/logs/ngc0000.log", encoding='utf-8')
log.addHandler(handler)
log = logging.getLogger(__name__)

logging.getLogger('asyncio').propagate = False
logging.getLogger('apscheduler').propagate = False
logging.getLogger('requests').propagate = False

owners = default.config()["owners"]

COGS = [x[:-3] for x in sorted(os.listdir('././cogs')) if x.endswith('.py') and x != "__init__.py"]

async def get_prefix(bot, message):
    if message.guild:
        prefix = default.config()["prefix"]
        return commands.when_mentioned_or(prefix)(bot, message)
    #prefix = await self.field("SELECT Prefix FROM guilds WHERE GuildID = ?", message.guild.id)
    #prefix = await bot.record("SELECT Prefix FROM guilds WHERE GuildID = ?", message.guild.id)
    #print(prefix)
    #return commands.when_mentioned_or(prefix[0])(bot, message)

class Bot(BotBase):
    def __init__(self):

        super().__init__(command_prefix=get_prefix, case_insensitive=True, owner_ids=owners, intents=discord.Intents.all(),)
        connection_task = self.loop.create_task(self.connection())
        self.cxn = self.loop.run_until_complete(connection_task)

        cursor_task = self.loop.create_task(self.cursor())
        self.cur = self.loop.run_until_complete(cursor_task)


        self.db_updater.start()


    async def connection(self):
        return await aiosqlite.connect(DB_PATH, check_same_thread=False)

    async def cursor(self):
        return await self.cxn.cursor()

    async def with_commit(func):
        async def inner(self, *args, **kwargs):
            func(*args, **kwargs)
            await self.commit()

        return  inner

    @with_commit
    async def build(self):
        if os.path.isfile(BUILD_PATH):
            await self.scriptexec(BUILD_PATH)

    async def commit(self):
        await self.cxn.commit()


    async def close(self):
        await self.cxn.close()


    async def field(self, command, *values):
        await self.cur.execute(command, tuple(values))


        if (fetch := await self.cur.fetchone()) is not None:
            return fetch[0]


    async def record(self, command, *values):
        await self.cur.execute(command, tuple(values))
        return await self.cur.fetchone()

    async def records(self, command, *values):
        await self.cur.execute(command, tuple(values))

        return await self.cur.fetchall()

    async def column(self, command, *values):
        await self.cur.execute(command, tuple(values))

        return [item[0] for item in  await self.cur.fetchall()]

    async def execute(self, command, *values):
        await self.cur.execute(command, tuple(values))

    async def multiexec(self, command, valueset):
        await self.cur.executemany(command, valueset)

    async def scriptexec(self, path):
        with open(path, "r", encoding="utf-8") as script:
            await self.cur.executescript(script.read())



    def setup(self):
        for cog in COGS:
            print(f"Loaded: {str(cog).upper()}")
            self.load_extension(f"cogs.{cog}")
        

    def run(self, version):
        self.VERSION = default.config()["version"]

        self.setup()

        self.token = default.config()["token"]

        super().run(self.token, reconnect=True)

    
    async def process_commands(self, message):
        ctx = await self.get_context(message, cls=commands.Context)
        if ctx.command is not None:
            await self.invoke(ctx)


    @tasks.loop(minutes=1)
    async def db_updater(self):
        await self.update_db()

    @db_updater.before_loop
    async def before_some_task(self):
        await self.wait_until_ready()
        #Not pretty but might as well set the bots status here
        await self.set_status()
        await db.tester()


    async def set_status(self):

        if default.config()["activity"] == "listening":
            a = discord.ActivityType.listening
        elif default.config()["activity"] == "watching":
            a = discord.ActivityType.watching
        elif default.config()["activity"] == "competing":
            a = discord.ActivityType.competing
        else:
            a = discord.ActivityType.playing
        activity = discord.Activity(type=a, name=default.config()["presence"])
        await self.change_presence(status=default.config()["status"], activity=activity)

    async def update_db(self):

        await db.multiexec("INSERT OR IGNORE INTO guilds (GuildID, GuildName, GuildOwnerID, GuildOwner) VALUES (?, ?, ?, ?)",
        ((guild.id, guild.name, guild.owner.id, str(guild.owner)) for guild in self.guilds))
        await db.commit()

        await db.multiexec("INSERT OR IGNORE INTO roleconfig (server, whitelist, autoroles, reassign) VALUES (?, ?, ?, ?)",
        ((guild.id, None, None, True) for guild in self.guilds))
        await db.commit()


        await db.multiexec("INSERT OR IGNORE INTO logging VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
        ((str(guild.id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, None, None) for guild in self.guilds))
        await db.commit()

        member_list = self.get_all_members()
        for member in member_list:
            roles = ','.join([str(x.id) for x in member.roles if x.name != "@everyone"])
            names = member.display_name

            await db.execute("INSERT OR IGNORE INTO users VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
            roles, str(member.guild.id), None, str(member.id), names, 0, 0, 0)
        await db.commit()

        #member_list = self.get_all_members()
        #for member in member_list:
        #    user_info = await db.records(
        #        """ SELECT *
        #            FROM users 
        #            WHERE id=? 
        #            AND server=?
        #        """, member.id, member.guild.id
        #    )
        #    if user_info == []:
        #        roles = ','.join([str(x.id) for x in member.roles if x.name != "@everyone"])
        #        names = member.display_name
        #        await db.execute(
        #            """ INSERT OR IGNORE INTO users
        #                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        #            """, roles, str(member.guild.id), None, str(member.id), names, 0, 0, 0
        #        )
        #        db.commit()


    async def on_command_error(self, ctx, error):
        if isinstance(error, commands.NoPrivateMessage):
            await ctx.author.send('<:fail:812062765028081674> This command cannot be used in private messages.')
        elif isinstance(error, commands.DisabledCommand):
            await ctx.author.send('<:fail:812062765028081674> This command is disabled and cannot be used.')
        elif isinstance(error, commands.CommandInvokeError):
            print(f'In {ctx.command.qualified_name}:', file=sys.stderr)
            traceback.print_tb(error.original.__traceback__)
            print(f'{error.original.__class__.__name__}: {error.original}', file=sys.stderr)


    async def on_guild_join(self, guild):
        await self.update_db()


    async def on_ready(self):
        if not hasattr(self, 'uptime'):
            self.uptime = datetime.utcnow()

        global global_connection, global_cursor
        global_connection = await aiosqlite.connect(DB_PATH, check_same_thread=False)
        global_cursor = await global_connection.cursor()
        #print(global_cursor)
        #print(global_connection)

        """
        if os.name == 'nt':
            os.system('cls')
        else:
            try:
                os.system('clear')
            except Exception:
                for _ in range(100):
                    print()
        message = 'Logged in as %s.' % bot.user
        uid_message = 'Client ID: %s.' % bot.user.id
        user_count_message = f'Users: {len([ x for x in self.get_all_members()])}     Servers: {len(self.guilds)}'
        separator = '-' * max(len(message), len(uid_message), len(user_count_message))
        print(separator)
        try:
            print(message)
        except:
            print(message.encode(errors='replace').decode())
        print(uid_message)
        print(user_count_message)
        print(separator)
        """

    async def on_message(self, message):
        print(global_cursor)
        if message.author.bot:
            return
        if not message.guild:
            # This wasn't said in a server, process commands, then return
            await bot.process_commands(message)
            return
        try:
            message.author.roles
        except AttributeError:
            # Not a User
            await bot.process_commands(message)
            return
        # Check if we need to ignore or delete or react to the message
        ignore, delete, react = False, False, False
        respond = None
        for cog in bot.cogs:
            cog = bot.get_cog(cog)
            try:
                check = await cog.message(message)
            except AttributeError:
                # Onto the next
                continue
            # Make sure we have things formatted right
            if not type(check) is dict:
                check = {}
            if check.get("Delete",False):
                delete = True
            if check.get("Ignore",False):
                ignore = True
            try: respond = check['Respond']
            except KeyError: pass
            try: react = check['Reaction']
            except KeyError: pass
        if delete:
            # We need to delete the message - top priority
            await message.delete()
        if not ignore:
            # We're processing commands here
            if respond:
                # We have something to say
                await message.channel.send(respond)
            if react:
                # We have something to react with
                for r in react:
                    await message.add_reaction(r)
            await bot.process_commands(message)
bot = Bot()

class Database:
    def __init__(self):
        self.cxn = global_connection
        self.cur = global_cursor
        print(self.cxn)
        


    async def with_commit(func):
        async def inner(self, *args, **kwargs):
            func(*args, **kwargs)
            await self.commit()

        return  inner

    @with_commit
    async def build(self):
        if os.path.isfile(BUILD_PATH):
            await self.scriptexec(BUILD_PATH)

    #async def tester(self):
        #cur = await bot.global_connection.cursor()
        #await cur.execute("SELECT eyecount FROM users WHERE id = ? AND server = ?", (708584008065351681, 740734113086177433))
        #stuff = await global_cursor.fetchone()
        #print("+++++")
        #print(stuff)
        #more = await db.record("SELECT eyecount FROM users WHERE id = ? AND server = ?", 708584008065351681, 740734113086177433)
        #print(more)

    async def commit(self):
        await self.cxn.commit()


    async def close(self):
        await self.cxn.close()


    async def field(self, command, *values):
        await global_cursor.execute(command, tuple(values))


        if (fetch := await global_cursor.fetchone()) is not None:
            return fetch[0]


    async def record(self, command, *values):
        await global_cursor.execute(command, tuple(values))
        return await global_cursor.fetchone()

    async def records(self, command, *values):
        await global_cursor.execute(command, tuple(values))

        return await global_cursor.fetchall()

    async def column(self, command, *values):
        await global_cursor.execute(command, tuple(values))

        return [item[0] for item in  await global_cursor.fetchall()]

    async def execute(self, command, *values):
        print(global_cursor)
        await global_cursor.execute(command, tuple(values))

    async def multiexec(self, command, valueset):
        await global_cursor.executemany(command, valueset)

    async def scriptexec(self, path):
        with open(path, "r", encoding="utf-8") as script:
            await global_cursor.executescript(script.read())

db = Database()